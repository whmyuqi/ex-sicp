(load "global.scm")

(define (list-ref items n)
    (if (= n 0)
        (car items)
        (list-ref (cdr items) (- n 1)))
)

(define empty-board `())

; ((1 1) (2 3) ...(col row))
(define (safe? k board)
    (let ((cur-row (cadr (list-ref board (- k 1)))))
        (accumulate (lambda (point result)
                (if (= (car point) k)
                    (and #t result)
                    (and (not (= (cadr point) cur-row)) (not (= (abs (- (car point) k)) (abs (- (cadr point) cur-row)))) result)))
            #t board))
)
(define (adjoin-position row col board)
    (if (null? board)
        (list (list col row))
        (append board (list (list col row))))
)
(define (queens board-size)
    (define (queen-cols k)
        (if (= k 0)
            (list empty-board)
            (filter
                (lambda (positions) (safe? k positions))
                (flatmap
                    (lambda (rest-of-queens) 
                        (map (lambda (new-row) 
                            (adjoin-position new-row k rest-of-queens))
                            (enumerate-interval 1 board-size)))
                    (queen-cols (- k 1))))))
    (queen-cols board-size)
)

(define (draw-board board)
    (define (draw-row-line row-seq)
        (display " ")
        (for-each (lambda (row)
                (display "----")
            )
            row-seq)
        (display "-")
        (display "\n")
    )
    (let (
            (board-size (length board))
            (row-seq (enumerate-interval 1 (length board)))
        )
        (draw-row-line row-seq)
        (for-each (lambda (point)
                (for-each (lambda (row)
                        (if (= 1 row)
                            (display " | "))
                        (if (= row (cadr point))
                            (display "*")
                            (display " "))
                        (display " | ")
                    )
                    row-seq)
                (display "\n")
                (draw-row-line row-seq)
            )
            board
        )
    )
)

(define (cal-queens-and-draw n)
    (let ((queens-result (queens n)))
        (for-each (lambda (board) 
            (display board)
            (display "\n")
            (draw-board board)
        ) queens-result)
        (display (length queens-result))
    )
)
